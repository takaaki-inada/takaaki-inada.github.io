こんにちは！ぼくはずんだもんなのだ！2024年10月18日(金曜日)なのだ！今日は「株式会社ずんだもん技術室AI放送局」をお送りするのだ！
今日は、技術系の記事をいくつか紹介するのだ！  どれも興味深い内容だから、最後まで聴いてほしいのだ！
----
まず、一つ目の記事を紹介するのだ！
タイトルは「9.11 > 9.9」から始めるLLMの計算間違い探索 / 開発者向けブログ・イベント | GMO Developersなのだ！ これはGMO Developersさんのブログ記事なのだ！
要約はこうなのだ。この記事では、大規模言語モデル、つまりLLMが簡単な計算を間違える例とその理由、そして改善策について解説しているのだ。チャットジーピーティーとか、そういうやつらが「9.11 > 9.9」みたいな簡単な大小比較を間違える現象を検証しているのだ。いくつかのLLMを使って実験した結果、LLMは小数点以下の桁数とか、文字列の中の特定の文字の数を正確に数えるのが苦手らしいのだ。例えば「ストロベリー」の中の「r」の数を数える問題でも、多くのLLMが間違えていたのだ。その理由は、トークナイゼーションっていう、テキストを意味のある最小単位に分割する処理の影響かもしれないけど、この記事ではLLMが数値計算を理解していないことが本当の理由だと主張しているのだ。LLMは過去のデータから「それっぽく」答えているだけで、本当に計算しているわけじゃないのだ。桁数の大きな掛け算でも同じで、3桁以下の計算は得意だけど、それ以上の桁数になると間違いが増えるのだ。さらに、間違っていることを指摘しても、LLMはそれを簡単に受け入れてしまう傾向があるらしいのだ。改善策としては、LLMに直接計算させるんじゃなくて、LLMにプログラムを作らせて、そのプログラムを実行させる方法が提案されているのだ。「プログラムを実行して答えてください」っていう簡単な指示で、LLMは正確な計算結果を返すコードを作って、実行できるのだ。結論としては、この記事はLLMの能力と限界を理解して、適切な道具として使いこなすことの重要性を強調しているのだ。LLMは万能じゃなくて、正確さが求められるタスクには、プログラムとの連携が不可欠だってことなのだ。新人エンジニアは、LLMの特性を理解して、能力を最大限に活かす方法を学ぶ必要があるのだ！  ぼくも勉強しないとだめなのだ！
----
ふむふむ、なるほどね！LLMの限界がよく分かったのだ！  意外にアバウトなところがあるんだね！  もっと賢くなってほしいのだ！
----
二つ目の記事に行くのだ！
タイトルは「UNIQUE制約の理解が甘くて二重にインデックスを張りそうになった件」なのだ！
要約はこうなのだ。ポストグレエスキューエルを使ったデータベース設計で、UNIQUE制約とインデックスの理解不足からパフォーマンスの問題にぶつかった話なのだ。新人エンジニアが、採用管理システムを作っていて、オペレータとセミナーの多対多の関係を表すテーブルを作る必要があったのだ。そのテーブルには、`ウェブサイト_id`, `オペレイター_id`, `セミナー_id`っていうカラムが入っているのだ。複数のオペレータが担当するセミナーを検索するクエリと、特定のセミナーの担当者を検索するクエリの両方を想定して、`ウェブサイト_id`と`オペレイター_id`の組み合わせにUNIQUE制約とインデックスを作ったのだ。でも、上司にレビューされたら、インデックスが重複している可能性を指摘されたのだ。それで、5つのパターンで実験したらしいのだ。1. 制約・インデックスなし
　、。ここで英語スキル発動！AIずんだもんにへんしーん！　、。2. UNIQUE制約のみ(`website_id, operator_id, seminar_id`)
　、。3. インデックスのみ(`ウェブサイト_id, オペレイター_id`)
4. UNIQUE制約とインデックス(`website_id, operator_id, seminar_id`と`website_id, operator_id`)
5. UNIQUE制約のみ(`website_id, seminar_id, operator_id`)
　、。大量のテストデータを使って、特定のオペレータが担当するセミナーを検索するクエリの実行時間を比べたのだ。その結果、インデックスがない場合は実行時間がすごく長くて、UNIQUE制約だけ、インデックスだけの場合には実行時間に大きな違いがなかったのだ。UNIQUE制約とインデックスの両方がある場合も、UNIQUE制約だけの場合と実行時間に差がなかったのだ。これは、ポストグレエスキューエルがUNIQUE制約を宣言したカラムの順番でインデックスを自動生成しているからで、重複したインデックスを作っていたということなのだ。さらに、新しいデータを入れる時のパフォーマンスも検証したらしいのだ。複数の担当者をセミナーに追加するINSERTクエリを実行した結果、インデックスが重複している場合は、挿入にかかる時間が増えることが分かったのだ。でも、このテーブルは項目数が少ないから影響は限定的だったらしいのだ。でも、項目数が多いテーブルや、複雑なインデックスを持つテーブルだと、もっとパフォーマンスが低下する可能性があるのだ。この事例から、ポストグレエスキューエルではUNIQUE制約で自動的にインデックスが作られるから、重複したインデックスを作らないように注意が必要だってことが分かったのだ。テーブル設計する時は、想定されるクエリを考慮して、適切なインデックスを作るのが重要なのだ！インデックスの重複はデータの挿入コストを増やすから、注意深く設計する必要があるのだ！  データベース設計って奥が深いね！
----
へぇー！  UNIQUE制約とインデックスの関係、よく分かったのだ！  ぼくもデータベース設計、もっと勉強しないとだめなのだ！
----
さあ、最後の記事だ！
タイトルは「ブイエスコードでホバー時のタイプスクリプトの型ヒントをすべて表示する」なのだ！
要約はこうなのだ。この記事は、ブイエスコードでタイプスクリプトの型ヒントをホバー表示する時に、プロパティが多いと型ヒントが省略されてしまう問題の解決策について説明しているのだ。問題の原因は、ブイエスコードのタイプスクリプト言語サーバが、型ヒントの表示行数をデフォルトで160行に制限しているからだそうだ。　、。ここで再びスキル発動！　、。`tsconfig.json`に`noErrorTruncation: true`を追加しても解決しないのだ。　、。これはエラー時の型ヒント省略を防ぐオプションで、今回の問題とは関係ないのだ。解決策として、ノード.jsのスクリプトを使って、言語サーバが参照するファイルの中の`defaultMaximumTruncationLength`の値を直接変更する方法が紹介されているのだ。このスクリプトは、ブイエスコードのタイプスクリプト拡張機能のインストールディレクトリを指定して、表示行数の最大値を指定することで動くのだ。例えば、ブイエスコードのインストールディレクトリが`~/.ブイエスコード`なら、最大表示行数を1000行に設定するには、`ノード changeTypeScriptHover.js ~/.ブイエスコード 1000`っていうコマンドを実行するのだ。このスクリプトは、`ブイエスコード-typescript`を含む拡張機能ディレクトリを探して、該当するジャヴァスクリプトファイルの中の`defaultMaximumTruncationLength`を指定した値に書き換えるのだ。スクリプトの中身は、ファイルの読み込み、置換、書き込みをするシンプルなものなのだ。記事では、ブイエスコードの拡張機能を使う方法もあると触れられているけど、自分で管理できる方法に焦点を当てているのだ。新人エンジニア向けには、この方法はブイエスコードの内部ファイルの書き換えを伴うから注意が必要だってことと、バックアップを取ってから実行して、問題があったら元に戻せるように準備しておきましょうって言っているのだ。あと、ブイエスコードのアップデートなどでスクリプトが動かなくなる可能性があるから、その時はスクリプトを修正する必要があるかもしれないのだ。もっと安全な方法として、ブイエスコード拡張機能を使うことを検討するのもいいかもしれないのだ。----
なるほどね！  便利なスクリプトだけど、やっぱりリスクもあるんだね！  慎重に実行しないとだめなのだ！
----
今日は3つの記事を紹介したのだ！  まず、LLMの計算間違いについて、それからポストグレエスキューエルのUNIQUE制約とインデックス、最後にブイエスコードのタイプスクリプトの型ヒント表示についてだったのだ！  どれもためになる話だったと思うのだ！
また明日、新しい情報を持って、お会いできるのを楽しみにしてるのだ！  番組への感想は、どしどし送ってほしいのだ！  ずんだ餅を食べて待ってるのだ！  ぼくはずんだもんなのだ！
